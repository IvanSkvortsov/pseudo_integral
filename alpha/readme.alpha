---------- class alpha_map ----------
[0]- Table of content:
1 - What for?
2 - Fields
 2.1 - alphas
 2.2 - coefficients
 2.3 - normas
 2.4 - k powers
 2.5 - spherical harmonics
3 - Methods
 3.1 - Matrix
 3.2 - Allocation
 3.3 - Initialization of matrices' elements
 3.4 - Iteratrion
  3.4.1 - 1d-matrix iteration
  3.4.2 - 2d-matrix iteration
  3.4.3 - 3d-matrix iteration
4 - Instruction
...
[1]- What for? -> to store sizes, and positions ( struct {int _pos, _size;} ) of:
  a) basis set and pseudo potential;
  b) powers of |kx| = 2 * alp_x * CX (x = a, b; X = A, B), |k| = |ka+kb|;
  c) spherical harmonics S_{l,m}( k/|k| ), where k = ka + kb (3d-vector);
[2]- Fields:
  mapnX - nd-matrices (e.i. %_M_map1A - 1d-matrix)
> a) --- alphas:
  matrix elements are struct {int _pos, _size; }
    when fixed angular momentum lx (lx = la, lb, l) it's named a shell
    %_size - number of alphas in a shell
    %_pos  - position of 0'th alpha in a shell
  .%_M_map1A - 1d-matrix that is storage of number and position of 0'th alpha of basis set A in a shell with angular momentum la (la=0..la_max);
  .%_M_map1B - -//- basis set B, lb=0..lb_max;
  .%_M_map1C - -//- pseudo potential, l=0..l_max - scalar part, l=(l_max+1)..(l_max+lso_max) - spin-orbit part;
  .%_M_map2AB - 2d-matrix, product of A and B matrices,
  .%_M_map3ABC - 3d-matrix, product of A, B, and C matrices;
    %map2AB_size(la, lb) /* wrap to %_size */ = %map1A_size( la ) * %map1B_size( lb );
    %map3ABC_size(la, lb, l) /* wrap to %_size */ = %map1A_size( la ) * %map1B_size( lb ) * %map1C_size( l );
    %map2AB_pos(la, lb) and %map3ABC_pos(la, lb, l) - wrap to %_pos values - are calculated according to 'new' %_size values;
      %_M_map1A->size() = (la_max + 1);
      %_M_map1B->size() = (lb_max + 1);
      %_M_map1C->size() = (l_max + 1 + lso_max);
      %_M_map2AB->size() = (la_max + 1) * (lb_max + 1);
      %_M_map3ABC->size() = (la_max + 1) * (lb_max + 1) * (l_max + 1 + lso_max);
> a) --- coefficients:
  matrix elements are struct {int _pos, _size; }// only %_size variable is used;
    %_size - number of basis functions in a shell
  .%_M_map1A_d - number of basis functions of basis set A in a shell with ang. mom. la;
  .%_M_map1B_d - -//- basis set B, lb
  .%_M_map1C_d - -//- pseudo potential, l;
  .%_M_map3ABC_d - product of A, B, and C matrices;
      %_M_map1A_d->size() = (la_max + 1);
      %_M_map1B_d->size() = (lb_max + 1);
      %_M_map1C_d->size() = (l_max + 1 + lso_max);
      %_M_map3ABC_d->size() = (la_max + 1) * (lb_max + 1) * (l_max + 1 + lso_max);
  P.S. basis function:  bf = Sum_{n=0}{nmax} d_n bp_n, where bp_n - n'th primitive, d_n - n'th coefficient in basis function expansion;
       basis primitive: bp = exp( -alp_x * rX^2 ), where rX = r - X, X - center of primitive
  a) --- normas:
  matrix elements are integer variables
    %_pos - position of 0'th norm. coef. in a shell with ang.mom. lx and powers nx,ny,nz
  .%_M_map1A_norm - positions of 0'th normalization coefficient of basis set A in a shell with ang.mom. la, and x,y,z components' powers ax,ay,az;
  .%_M_map1B_norm - -//- basis set B; lb; bx,by,bz;
  .%_M_map2AB_norm - product of A and B matrices;
      %_M_map1A_norm->size() = (la_max + 1) * (la_max + 2) * (la_max + 3) / 6;
      %_M_map1B_norm->size() = (lb_max + 1) * (lb_max + 2) * (lb_max + 3) / 6;
      P.S. Sum_{n=0}^{n_max} Sum_{i=0}^{n} i = (n_max + 1) * (n_max + 2) * (n_max + 3) / 6;
> b) --- k powers:
  matrix elements are struct {int _pos, _size; }
    %_size = max_pow + 1;// (%_size - 1) - maximum power of |kx| in a shell
    %_pos  - position of 0'th power in a shell 
    kA = 2 * alp_a * |CA|;
    kB = 2 * alp_b * |CB|;
    k = 2 * |(alp_a * CA + alp_b * CB)|;
  .%_M_map1powkA - max power and positions of 0'th powers of kA in a shell with ang.mom. la;
  .%_M_map1powkB - -//- kB in a shell with ang.mom. lb;
  .%_M_map2powk  - -//- |k| in a shell with ang.mom. la, lb;
      %_M_map1powkA->size() = (la_max + 1);
      %_M_map1powkB->size() = (lb_max + 1);
      %_M_map2powk->size()  = (la_max + 1) * (lb_max + 1);
> c) --- spherical harmonics:
  matrix elements are struct {int _pos, _size; }
    %_size = Sum_{lx=0}^{la+lb} (2*lx + 1), fixed la, lb;
    %_pos  = Sum_{i,j=0}^{la,lb} %_size(i, j) * %alpha_map::map2AB_size(i, j);
    P.S. %alpha_map::map2AB_size(i, j) = %alpha_map::map1A_size( i ) * %alpha_map::map1B_size( j ), where
      %map1A_size( i ) - number of alphas of basis set A in a shell with ang.mom. i
      %map1B_size( j ) - number of alphas of basis set B in a shell with ang.mom. j
  .%_M_map2slm - sizes and positions of 0'th spher.harm. in a shell with la, lb;
      %_M_map2slm->size() = (la_max + 1) * (lb_max + 1);
[3]- Methods:
  (records like 'map1##X...' have X = A, B, C, A_d, B_d, C_d, powkA, powkB, A_norm, B_norm)
  (records like 'map2##X...' have X = AB, AB_norm, powk, slm)
  (records like 'map3##X...' have X = ABC, ABC_d)
> Matrix:
  1d-matrix
  . %M_map1##X##_size() = %_M_map1##X->size();
  . %M_map1##X##_data() = %_M_map1##X->data();
  2d-matrix
  . %M_map2##X##_size() = %_M_map2##X->size();
  . %M_map2##X##_n() = %_M_map2##X->n();
  . %M_map2##X##_m() = %_M_map2##X->m();
  . %M_map2##X##_data() = %_M_map2##X->data();
  3d-matrix
  . %M_map3##X##_size() = %_M_map3##X->size();
  . %M_map3##X##_n() = %_M_map3##X->n();
  . %M_map3##X##_m() = %_M_map3##X->m();
  . %M_map3##X##_p() = %_M_map3##X->p();
  . %M_map3##X##_data() = %_M_map3##X->data();
> Allocation
  . %comp_size( _lmax_struct const & )const - compute needed size of memory (in bytes) to allocate all 1d-, 2d-, 3d-matrices;
    P.S. %M_map1##X##_size(), %M_map2##X##_size(), and %M_map3##X##_size() are recalculated;
  . %comp_size_##mapnX( _lmax_struct const & )const - methods of separate calculation of matrix's sizes;
    mapnX = map1X - all 1d-matrices except map1powkA, and map1powkB;
    mapnX = map2X - all 2d-matrices except map2powk, and map2slm;
    mapnX = map3X - all 3d-matrices;
    mapnX = map1powkA;
    mapnX = map1powkB;
    mapnX = map2powk - 2d-matrices map2powk, and map2slm;
  . %write_map( memorystream & , _lmax_struct const & ) - inition of pointers %_M_#mapnX, and others; (needed further "Initialization ..." paragraph);
  . %write_##mapnX( memorystream & )
  . %read_map( memorystream & ) - initialization of pointers (not needed further "Initialization of matrices' elements")
  . %read_##mapnX( memorystream & )
     map1X - all 1d-matrices except map1powkA, and map1powkB;
     map2X - all 2d-matrices except map2powk, and map2slm;
     map3X - all 3d-matrices;
     map1powkA - 1d-matrix map1powkA;
     map1powkB - 1d-matrix map1powkB;
     map2powk - 2d-matrix map2powk;
     map2slm - 2d-matrix map2slm;
> Initialization of matrices' elements:
  . 0. %init_map1X( const int * A_size, const int * B_size, const int * C_size ) - initialize elements of %_M_map1A, %_M_map1B, and %_M_map1C;
  . 1. %init_map2X() - initialize elements of %_M_map2AB;
  . 2. %init_map3X() - initialize elements of %_M_map3ABC;
  . 4. %init_map1powk##X() - initialize elements of %_M_map1powkA, and %_M_map1powkB;
  . 5. %init_map2powk() - initialize elements of %_M_map2powk;
  . 6. %init_map2slm() - initialize elements of %_M_map2slm;
  .  %init_map( const int * A_size, const int * B_size, const int * C_size ) - run methods 0-6 %init_##mapnX;
  . 0. %init_map1X_d(const int * A_dsize, const int * B_dsize, const int * C_dsize) - initialize elements of %_M_map1A_d, %_M_map1B_d, and %_M_map1C_d;
  . 1. %init_map3X_d() - initialize elements of %_M_map3ABC_d;
  .  %init_mapd( const int * A_dsize, const int * B_dsize, const int C_dsize ) - run methods 0-1 %init_##mapnX##_d;
  . 0. %init_map1X_norm() - initialize elements of %_M_map1A_norm, and %_M_map1B_norm;
  . 1. %init_map2AB_norm() - initialize elements of %_M_map2AB_norm;
  .  %init_map_norm() - run methods 0-1 %init_##mapnX##_norm();
> Iteration:
* 1d-matrix iteration:
  a. serial access:
  . 1. %map1##X##_set_lx( lx ) - set iterator to position pointing to a shell with ang.mom. lx;
  . %map1##X##_size() - get number of elements in a shell lx,    wrap to %_size element of struct {int _pos, _size; };
  . %map1##X##_pos()  - get position of 0'th element in a shell, wrap to %_pos  element of struct {int _pos, _size; };
  . %map1##X##_idx( ix ) = %map1##X##_pos() + ix; semi-random access to index of ix'th element of a shell with ang.mom. lx;
  . 2. %map1##X##_set_ix( ix ) - set 'iterator2' to position pointing to a ix'th element of a shell with ang.mom. lx;
  . %map1##X##_idx() = %map1##X##_pos() + ix;
  b. random access:
  . %map1##X##_size( lx );
  . %map1##X##_pos( lx );
  . %map1##X##_idx( lx, ix );
* 2d-matrix iteration:
  a. serial access:
  . 1. %map2##X##_set_la( la );
  . 2. %map2##X##_set_lb( lb ) - set iterator pointing to a shell (la, lb);
  . %map2##X##_size() - get number of elements in a shell (la, lb);
  . %map2##X##_pos()  - get position of 0'th element in a shell (la, lb);
  . %map2##X##_idx( ia, ib ) = %map2##X##_pos() + (ia * %map1##Xb##_size() + ib); get index of (ia, ib)'th element of a shell (la, lb);
    P.S. such semi-random access needs to be set %map1##Xb##_set_lx( lb );
  . 3. %map2##X##_set_ia( ia );
  . 4. %map2##X##_set_ib( ib ) - set iterator pointing to (ia, ib)'th element of a shell (la, lb);
  . %map2##X##_idx() - get index of (ia, ib)'th element of shell (la, lb);
  b. random access:
  . %map2##X##_size( la, lb );
  . %map2##X##_pos( la, lb );
  . %map2##X##_idx( la, i, lb, j );
* 3d-matrix iteration:
  a. serial access:
  . 1. %map3##X##_set_la( la );
  . 2. %map3##X##_set_lb( lb );
  . 3. %map3##X##_set_l( l ) - set iterator pointing to a shell (la, lb, l);
  . %map3##X##_size() - get number of elements in a shell (la, lb, l);
  . %map3##X##_pos()  - get position of 0'th element in a shell (la, lb, l);
  . %map3##X##_idx(ia, ib, ic) = %map3##X##_pos() + (ia * %map1##Xb##_size() + ib) * %map1##Xc##_size();
    get index of (ia, ib, ic)'th element of a shell (la, lb, l);
    P.S. such semi-random access needs to be set %map1##Xb##_set_lx( lb ), and %map1##Xc##_set_lx( l );
  . 4. %map2##X##_set_ia( ia );
  . 5. %map2##X##_set_ib( ib );
  . 6. %map2##X##_set_ic( ic ) - set iterator pointing to (ia, ib, ic)'th element of a shell (la, lb, l);
  . %map2##X##_idx() - get index of (ia, ib, ic)'th element of shell (la, lb, l)
  b. random access:
  . %map2##X##_size( la, lb, l );
  . %map2##X##_pos( la, lb, l );
  . no random access to index, %map2##X##_idx( la, ia, lb, ib, l, ic );
[4] - Instruction:
  . 1. set mapping type, method %set_mapping_##x(), (x = max, mid, min - (A!=C!=B), (A!=C==B), (A==C==B), respectively);
  . 2. initialize pointers, method %write_map( memorystream & , _lmax_struct const & );
  . 3. initialize matrices' elements, methods %init_##mapnX;
[0] - Table of content:
1 - Fields
2 - Methods
 2.1 - Matrix
 2.2 - Allocation
 2.3 - Initialization of matrices' elements
 2.4 - Iteration
  2.4.1 - serial access
  2.4.2 - random access
3 - Instruction ...

---------- class alpha_val ----------
[1] - Fields:
  mxnX - nd-matrix;
  . inherited from class alpha_map;
  . %_M_mx1A - storage of alpha values of basis set A;
  . %_M_mx1B - -//- basis set B;
  . %_M_mx1C - -//- pseudo potential;
  . %_M_mx1C_nk - storage of nk (powers of r) values of pseudo potential;
  . %_M_mx1kA - storage of kA = 2 * alp_a * |CA|;
  . %_M_mx1kB - storage of kB = 2 * alp_b * |CB|;
      %_M_mx1A->size() - number of all alphas in basis set A;
      %_M_mx1B->size() - -//- basis set B;
      %_M_mx1C->size() - -//- pseudo potential;
      %_M_mx1C_nk->size() = %_M_mx1C->size();
  . %_M_mx1A_norm - normalization coefficients of primitives of basis set A;
  . %_M_mx1B_norm - normalization coefficients of primitives of basis set B;
  . %_M_mx2AB_norm - product of A, and B matrices;
  . %_M_mx2k - storage of k = 2 * |(alp_a * CA + alp_b * CB)|;
  . %_M_mx2AB_exp - storage of values exp( -alp_a * |CA|^2 - alp_b * |CB|^2 );
      %_M_mx1A_norm->size() = Sum_{lx = 0}^{la_max} (lx + 1) * (lx + 2) / 2 * %alpha_map::map1A_size( lx );
      %_M_mx1B_norm->size() = Sum_{lx = 0}^{lb_max} (lx + 1) * (lx + 2) / 2 * %alpha_map::map1B_size( lx );
      %_M_mx2AB_norm->size() = %_M_mx1A_norm->size() * %_M_mx1B_norm->size();
[2] - Methods:
> Matrix:
  . %M_##mxnX##_size() = %_M_##mxnX->size();
  . %M_##mxnX##_data() = %_M_##mxnX->data();
  . %M_##mxnX##_data( int i ) = %_M_##mxnX->data() + i;
  . %M_##mxnX( int i ) - get i'th element of %_M_##mxnX;
  . %M_##mxnX##_n() = %_M_##mxnX->n();// for 2d-matrices and higher;
  . %M_##mxnX##_m() = %_M_##mxnX->m();// for 2d-matrices and higher;
  . %M_##mxnX##_p() = %_M_##mxnX->p();// for 3d-matrices and higher;
> Allocation:
  . %comp_size( _lmax_struct const & __lmax, _alpsize_struct const & __alpsize, const int * __A_size, const int * __B_size ); - memory size in bytes;
      struct _alpsize_struct {int _a_size, _b_size, _c_size; } - it is used to store total number of alphas in basis set A, B, and pseudo potential;
        %_M_mx1A->size() = %_alpsize_struct::_a_size;
        %_M_mx1B->size() = %_alpsize_struct::_b_size;
        %_M_mx1C->size() = %_alpsize_struct::_c_size;
      struct _lmax_struct {int _la_max, _lb_max, _l_max, _lso_max; } - used to store maximum angular momenta of basis set A, B, and pseudo potential;
      Sum_{lx=0}^{la_max} __A_size[lx] = %_alpsize_struct::_a_size; - number of alphas in each shell of basis set A;
      Sum_{lx=0}^{lb_max} __B_size[lx] = %_alpsize_struct::_b_size; - -//- basis set B;
      Sum_{lx=0}^{l_max + lso_max} __C_size[lx] = %_alpsize_struct::_c_size; - -//- pseudo potential;
  P.S. this method includes %alpha_map::comp_size( _lmax_struct const & __lmax ) method, so that resulting size is sum of memory size needed
    for alpha_map and memory size needed for alpha_val matrices allocation;
  . %write_mxalp( memorystream & ms, _lmax_struct const & __lmax, _alpsize_struct const & __alpsize ); - pointers initialization;
  . %read_mxalp( memorystream & ms ); - pointers initialization;
> Initialization of matrices' elements:
  . 0. %init_mx1_alp( T const * A_alp, T const * B_alp, T const * C_alp ) - initialize elements of %_M_mx1A, %_M_mx1B, and %_M_mx1C matrices;
  . 1. %init_mx1X( matrix_1d * , T const * X_alp, const int x_size, T const & CX_len ) - initialize elements of %_M_mx1k##X, X = A, B;
  . 2. %init_mx1kB3( T const * CB, T const * B_alp ) - initialize elements of %_M_mx1kB3;
  . 3. %init_mx2k( T const * A_alp, T const * B_alp, T const & CA_len, T const & CB_len, T const & CA_x_CB ) - initialize elements of %_M_mx2k;
  .  %init_mxalp( T const * A_alp, T const * B_alp, T const * C_alp, T const * CA, T const * CB ) - run 0-3 methods;
  . %init_mx1C_nk( int const * C_nk ) - initialize elements of %_M_mx1C_nk;
  . 0. %init_mx1X_norm( T const * A_alp, T const * B_alp ) - initialize elements of %_M_mx1A_norm, and %_M_mx1B_norm;
  . 1. %init_mx2AB_norm() - initialize elements of %_M_mx2AB_norm;
  .  %init_norm( T const * A_alp, T const * B_alp ) - run 0-1 methods;
  . %init_exp( T const * A_alp, T const * B_alp, T const & sqr_CA, T const & sqr_CB ) - initialize elements of %_M_mx2AB_exp;
> Iteration:
* a. serial access:
  . %mxnX##_set_idx( int _idx_ ) - set iterator pointing to _idx_'th element of %_M_##mxnX; %iter = %_M_##mxnX->data() + %_idx_;
  . %mxnX##_set_idx() = %_M_##mxnX->data() + %alpha_map::mapnX##_idx()// corresponding index (%mapnX##_idx()) needed to bet set;
  . %mxnX() - return value of _idx_'th element of %_M_##mxnX;
* b. random access:
  1d-matrix:
    X = A, B, C, C_nk, kA, kB:
  . %mx1X( int lx, int i ) = %M_##mx1X( this->alpha_map::map1X##_idx( lx, i ) );
  . %mx1X( int i ) = %M_##mx1X( alpha_map::map1X##_pos() + i );
  P.S. (mx1A, mx1kA) use map1A in iteration; (mx1B, mx1kB) <-> map1B; (mx1C, mx1C_nk) <-> map1C;
    X = A_norm, B_norm:
  . %mx1X( int lx, int i_xyz, int i ) = %M_##mx1X( alpha_map::map1X##_idx( lx, i_xyz, i ) );// i_xyz - is index of (x,y,z)-triple: x+y+z = lx;
  . %mx1X( int i ) = %M_##mx1X( alpha_map::map1X##_pos() + i );
  P.S. mx1A_norm <-> map1A_norm; mx1B_norm <-> map1B_norm;
  2d-matrix:
    X = k, AB_exp;
  . %mx2X( int la, int i, int lb, int j ) - get (la, lb)'th shell's (i, j)'th element of %_M_##mx2X; %M_##mx2X( alpha_map::map2AB_idx(la, i, lb, j) );
  . %mx2X( int i, int j ) = %M_##mx2X( alpha_map::map2AB_idx( i, j ) ); - semi-random access;
  P.S. mx2X linked with map2AB;
    X = AB_norm; (mx2AB_norm) <-> map2AB_norm;
  no random access, there is only semi-random:
  . %mx2X( int i, int j );
[3] - Intstruction:
...

---------- class alpha_pow ----------
[1] - Fields:
  . inherited from alpha_val;
  . %_M_mx1powkA - powers of kA, kA = 2 * alp_a * |CA|;
  . %_M_mx1powkB - powers of kB, kB = 2 * alp_b * |CB|;
  . %_M_mx2powk - powers of k, k = 2 * |(alp_a * CA + alp_b * CB)|;
[2] - Methods:
> Matrix:
  . %M_##mxnpowkX##_size();
  . %M_##mxnpowkX##_data();
  ...
> Allocation:
  . %comp_size( _lmax_struct const & __lmax, _alpsize_struct const & __alpsize, const int * __A_size, const int * __B_size );
  P.S. this method includes %alpha_val::comp_size method, so that resulting memory size value is the sum of %alpha_val::comp_size(...)
    and memory size needed for allocation mxnpowkX matrices;
  . %write_mxpow( memorystream & ms, ... );
  . %read_mxpow( memorystream & ms );
> Initialization of matrices' elements:
  . %init_mxpow( T const * CA, T const * A_alp, T const * CB, T const * B_alp );
> Iteration:
  a. serial access:
    powkX = powkA, powkB:
  . %mx1##powkX##_set_idx( int _idx_ ) - set iterator pointing to _idx_'th element of %_M_mx1##powkX; %iter = %M_mx1##powkX( _idx_ );
  . %mx1##powkX##_set_idx(); %iter = %M_mx1##powkX( %alpha_map::map1##powkX##_idx() );
  . %mx1##powkX( int n ) - get n'th power of _idx_'th element of %_M_mx1##powkX;
    P.S. n = 0..(alpha_map::map1##powkX##_size()-1);
    mx2powk methods:
  no method mx2powk_set_idx( int _idx_ );
  . %mx2powk_set_idx(); %iter = %M_mx2powk( alpha_map::map2powk_idx() );
  . %mx2powk( int n ) - get n'th power of k;
  b. random access:
  . %mx1##powkX( int lx, int _idx_ ) - get pointer to 0'th power of kX; usage is: %mx1##powkX( lx, _idx_ )[n] - n'th power of kX;
  . %mx1##powkX( int lx, int _idx_, int n ) - get n'th power of kX;
  . %mx2powk( int la, int i, int lb, int j ) - get pointer to 0'th power of k;
  . %mx2powk( int la, int i, int lb, int j, int n ) - get n'th power of k;
  P.S. there is no semi-random access;
[3] - Instruction:
...
---------- class alpha_slm ----------
[0] - Table of content:
1 - Fields
2 - Methods
 2.1 - Initialization of matrix's ( std::vector's ) elements
 2.2 - Iteration
3 - Intstruction

[1] - Fields:
  . inherited from alpha_pow;
  . inherited from std::vector;
[2] - Methods:
> Initialization of matrix's (std::vector's) elements:
  . %init_mxslm( T const * CA, T const * A_alp, T const * CB, T const * B_alp, matrix_slm const & mx_slm );
    initialization matrices:
      1. run %init_mx1powkA( ... );// %alpha_pow::_M_mx1powkA;
      2. run %init_mx1powkB( ... );// %alpha_pow::_M_mx1powkB;
      3. run %init_mx2slm( ... );// +initialize %alpha_val::_M_mx2k, %alpha_pow::_M_mx2powk;
      4. run %init_mx1kB3( ... );// %alpha_val::_M_mx1kB3;
  . %init_mx2slm( T const * CA, T const * A_alp, T const * CB, T const * B_alp, matrix_slm const & mx_slm );
    additionally initialize %alpha_val::_M_mx2k, %alpha_pow::_M_mx2powk;
> Iteration:
  a. serial access:
  . %mx2slm() = std::vector::data() + %alpha_map::map2slm_idx(); - get address of 0'th spherical harmonic of %map2slm_idx()'th element of ~%_M_mx2slm;
  . %mx2slm_set_lmb( int _lmb_ ) - set iterator pointing to spherical harmonic with ang.mom. %_lmb_;
  . %mx2slm( int m ) - get spher.harm. ( %_lmb_, %m ) - with ang.mom. %_lmb_, and projection to Oz axis %m;
  b. random access (semi-random):
  . %mx2slm( int _lmb_, int m );
[3] - Instruction:
...
---------- class alpha_mem ----------
[1] - Fields:
  . inherited from class alpha_pow;
[2] - Methods:
> Allocation:
  . %memory_create( ... ) - file creation (for read-write) by using memory mapping technology;
    runs %alpha_pow::comp_size(...) to calculate needed memory size; then runs %alpha_pow::write_mxpow(...) to initialize matrices (pointers);
  . %memory_open( ... ) - open existing file for read-only;
    runs %alpha_pow::read_mxpow(...) to init matrices (pointers);
> Initialization:
  . %init_map(); - runs %alpha_map::init_map(...), %alpha_map::init_map_norm(...), and %alpha_map::init_mapd(...);
